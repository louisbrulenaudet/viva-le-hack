import base64
import io
import time

from aiocache import cached
from fastapi import APIRouter, File, HTTPException, UploadFile
from PIL import Image

from app._enums import ImageMimeTypes
from app.core.callbacks import ReviewCallback
from app.core.completion import CompletionModel
from app.core.config import settings
from app.models.models import SignDetector
from app.services.plate_analysis import analyze_bacterial_plate
from app.utils.encoders import ImageEncoder
from app.utils.image_processing import correct_inversion

router = APIRouter(tags=["sync"])


CALLBACKS: dict[str, ReviewCallback] = {
    "review": ReviewCallback(),
}


@router.get("/ping", response_model=dict, tags=["Health"])
async def ping() -> dict:
    """
    Health check endpoint for readiness/liveness probes.
    """
    now: int = int(time.time())
    uptime: int = now - int(settings.service_start_time)
    return {
        "status": "ok",
        "version": settings.version,
        "uptime": uptime,
        "timestamp": now,
    }


@router.post(
    "/completion",
    tags=["completion", "llm", "sync", "model", "text"],
    description="Endpoint to generate text completions for a given input using a registered model.",
)
@cached(ttl=60)
async def completion(file: UploadFile = File(...)) -> dict:
    """
    Endpoint to generate text completions for a given input using a registered model.

    This endpoint allows clients to send input data, and returns the corresponding completions generated by the specified system.

    Args:
        data (UploadFile): The input data containing the model name and input text.

    Returns:
        CompletionResponse: A response object containing the model name, description, queries, and answers generated by the model.
    """
    if file.content_type not in [
        ImageMimeTypes.JPEG,
        ImageMimeTypes.PNG,
        ImageMimeTypes.PNG,
    ]:
        raise HTTPException(status_code=400, detail="Image format not supported.")

    contents = await file.read()
    image = Image.open(io.BytesIO(contents))
    image, _ = correct_inversion(image)

    buf = io.BytesIO()
    image.save(buf, format="PNG")
    image_b64 = base64.b64encode(buf.getvalue()).decode()

    prompt = settings.get_rendered_prompt("sign_detector")

    model = CompletionModel(token=settings.openai_api_key)
    result = model.generate(
        "",
        images=[f"data:{file.content_type};base64,{image_b64}"],
        response_format=SignDetector,
        system_instruction=prompt,
    )

    # ReviewCallback().execute(
    #     **result.data
    # )

    return {"data": result.data}


    # settings.r2_client.upload_fileobj(  # type: ignore
    #     Fileobj=BytesIO(json.dumps(...).encode("utf-8")),
    #     Bucket="openai-viva-le-hack",
    #     Key="/name_of_the_file.json",
    #     ExtraArgs={"ContentType": "application/json"},
    # )
